# ai_assistant/views.py

from django.shortcuts import render
from django.views import View
from django.http import JsonResponse
from django.contrib.auth.mixins import LoginRequiredMixin
from django.views.decorators.csrf import csrf_exempt
from django.utils.decorators import method_decorator
import json
import logging

from .services import get_gemini_chat_response, get_smart_match_suggestions
from .models import AIChatMessage, SmartMatchLog
from .forms import ChatMessageForm
from swaps.models import SwapRequest # Import SwapRequest to fetch other requests

logger = logging.getLogger(__name__)

@method_decorator(csrf_exempt, name='dispatch') # For AJAX POST requests without CSRF token in development
class ChatbotView(LoginRequiredMixin, View):
    """
    Handles the AI Chatbot UI and AJAX interactions.
    """
    template_name = 'ai_assistant/chatbot_ui.html'

    def get(self, request, *args, **kwargs):
        # Load chat history for the current user
        chat_history = AIChatMessage.objects.filter(user=request.user).order_by('timestamp')
        context = {
            'chat_history': chat_history,
            'form': ChatMessageForm()
        }
        return render(request, self.template_name, context)

    def post(self, request, *args, **kwargs):
        # Handle AJAX POST requests for new chat messages
        if request.headers.get('x-requested-with') == 'XMLHttpRequest':
            try:
                data = json.loads(request.body)
                user_message = data.get('message')

                if not user_message:
                    return JsonResponse({'error': 'Message cannot be empty'}, status=400)

                # Save user message to history
                AIChatMessage.objects.create(
                    user=request.user,
                    message_type='USER',
                    content=user_message
                )

                # Prepare chat history for Gemini (excluding the current message)
                # Gemini expects history in a specific format
                gemini_chat_history = []
                for msg in AIChatMessage.objects.filter(user=request.user).order_by('timestamp'):
                    gemini_chat_history.append({
                        'role': 'user' if msg.message_type == 'USER' else 'model',
                        'parts': [{'text': msg.content}]
                    })
                
                # Get AI response
                ai_response_text = get_gemini_chat_response(user_message, gemini_chat_history[:-1]) # Pass history without current user message for the API call

                # Save AI response to history
                AIChatMessage.objects.create(
                    user=request.user,
                    message_type='AI',
                    content=ai_response_text
                )

                return JsonResponse({'message': ai_response_text})
            except json.JSONDecodeError:
                return JsonResponse({'error': 'Invalid JSON'}, status=400)
            except Exception as e:
                logger.error(f"Error in ChatbotView POST: {e}")
                return JsonResponse({'error': 'An internal server error occurred.'}, status=500)
        
        return JsonResponse({'error': 'Invalid request'}, status=400)


class SmartMatchSuggestionsView(LoginRequiredMixin, View):
    """
    Displays smart matching suggestions generated by the AI.
    """
    template_name = 'ai_assistant/smart_match_suggestions.html'

    def get(self, request, *args, **kwargs):
        user = request.user

        # Helper function to serialize location objects
        def serialize_location(location):
            if not location:
                return None
            return {
                'id': location.id,
                'name': location.name,
            }

        # Prepare user profile data for the AI
        user_profile_data = {
            'username': user.username,
            'full_name': user.full_name,
            'email': user.email,
            'school_type': user.school_type,
            'subjects': user.subjects,
            'current_location': {
                'county': serialize_location(user.current_county),
                'subcounty': serialize_location(user.current_subcounty),
                'ward': serialize_location(user.current_ward),
            },
            'desired_swap_location': {
                'county': serialize_location(user.swap_to_county),
                'subcounty': serialize_location(user.swap_to_subcounty),
                'ward': serialize_location(user.swap_to_ward),
            },
            'is_profile_complete': user.is_profile_complete,
        }

        # Fetch existing swap requests from other users
        other_swap_requests = []
        for req in SwapRequest.objects.exclude(user=user).filter(status='PENDING'):
            other_swap_requests.append({
                'id': req.id,
                'user_username': req.user.username,
                'user_full_name': req.user.full_name,
                'user_current_location': {
                    'county': serialize_location(req.user.current_county),
                    'subcounty': serialize_location(req.user.current_subcounty),
                    'ward': serialize_location(req.user.current_ward),
                },
                'desired_location': {
                    'county': serialize_location(req.desired_county),
                    'subcounty': serialize_location(req.desired_subcounty),
                    'ward': serialize_location(req.desired_ward),
                },
                'notes': req.notes,
                'status': req.status,
            })

        # Get smart match suggestions from AI service
        suggestions = get_smart_match_suggestions(user_profile_data, other_swap_requests)

        # Log the AI interaction - serialize all data before passing to json.dumps
        log_data = {
            'user_profile': user_profile_data,
            'other_requests': other_swap_requests
        }
        
        SmartMatchLog.objects.create(
            user=user,
            prompt=json.dumps(log_data),
            ai_response=json.dumps(suggestions),
            suggestions_data=json.dumps(suggestions)
        )

        context = {
            'suggestions': suggestions
        }
        return render(request, self.template_name, context)